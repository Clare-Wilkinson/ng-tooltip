tagInputId: "**Sample tag input tooltip**"
idforexpressioninput: Here's an [**important** anchor link](#example)
jiraApprovalProject: Jira Project Key
jiraApprovalIssueType: Project Issue Type
jiraApprovalIssueKey: Jira Issue key
ONNtooltipId: Your pipeline name
specifyYourService: Harness Services represent your microservices/apps logically. You can propagate the same Service to as many stages as you need.
stageOverviewDeploymentType: Select the platform for your deployment. When you select a platform, its specific specs and settings appear.
deploymentTypeManifests: Add the configuration files that describe the desired state of your app in terms of Kubernetes API object descriptions. All files in **Manifests** must have the .yaml file extension. [Learn More](https://ngdocs.harness.io/article/ssbq0xh0hx)
deploymentTypeArtifacts: |-
    If the image location is not specified in your Deployment manifest, you can add the image location to Harness as an Artifact. 
    Next, you reference the Artifact you added to Harness in your manifest like this:
    `image: <+artifact.image>` 
    [Learn More](https://ngdocs.harness.io/article/4ifq51cp0i)
ciEditStage_name: Enter a name for the stage. [Learn more](https://ngdocs.harness.io/article/2chyf1acil)
ciEditStage_repoName: Enter the name of the Git repo containing your codebase. [Learn more](https://ngdocs.harness.io/article/8l31vtr4hi)
ciBuildStage_name: Enter a name for the stage. [Learn More](https://ngdocs.harness.io/article/2chyf1acil-add-a-stage)
dependencyBase_name: Enter a name for this Service Dependency step. [Learn More](https://ngdocs.harness.io/article/vo4sjbd09g-configure-service-dependency-step-settings)
ciRunStep_name: The Run step executes one or more commands on a container image. Enter a name for this Run step. [Learn More](https://ngdocs.harness.io/article/1i1ttvftm4-run-step-settings)
pluginStep_name: |-
    Enter a unique name for this Plugin step. 

    Plugins are Docker containers that perform predefined tasks. Plugins are configured as steps in your stage. Plugins can be used to deploy code, publish artifacts, send notifications, and more. [Learn More](https://ngdocs.harness.io/article/8r5c3yvb8k)
restoreCacheS3_name: |-
    Enter a name for this step.

    The [Save Cache to S3](https://ngdocs.harness.io/article/qtvjvrp9sn) step preserves files and directories between builds.

    You can restore cache using the [Restore Cache from S3](https://ngdocs.harness.io/article/zlpx6lli6d) step.
restoreCacheGcs_name: |-
    Enter a name for this step.

    The [Restore Cache from GCS](https://ngdocs.harness.io/article/e2o4sektz1) step restores files and directories that were saved using the [Save Cache to GCS](https://ngdocs.harness.io/article/11nzeuntrz) step.
savedS3Cache_name: |-
    Enter a name for this step.

    The [Save Cache to S3](https://ngdocs.harness.io/article/qtvjvrp9sn) step preserves files and directories between builds.

    You can restore cache using the [Restore Cache from S3](https://ngdocs.harness.io/article/zlpx6lli6d) step.
savedCacheGcs_name: |-
    Enter a name for this step.

    The [Restore Cache from GCS](https://ngdocs.harness.io/article/e2o4sektz1) step restores files and directories that were saved using the [Save Cache to GCS](https://ngdocs.harness.io/article/11nzeuntrz) step.
dockerHubStep_name: |-
    Enter a name for this step.

    The [Build and Push an Image to Docker Registry](https://ngdocs.harness.io/article/q6fr5bj63w) step creates a Docker image from a Dockerfile and pushes it to a Docker registry.
ciGcrStep_name: |-
    Enter a name for this step.

    The [Build and Push to GCR](https://ngdocs.harness.io/article/66ykcm0sf0) step creates a Docker image from a Dockerfile and pushes it to a GCR Docker repository.
ciEcrStep_name: |-
    Enter a name for this step.

    The [Build and Push to ECR](https://ngdocs.harness.io/article/aiqbxaef15) step creates a Docker image from a Dockerfile and pushes it to an ECR Docker repository.
jfrogArt_name: |-
    Enter a name for this step.

    The [Upload Artifacts to JFrog Artifactory](https://ngdocs.harness.io/article/gjoggc66fy) step creates a Docker image from a Dockerfile and pushes it to a JFrog Artifactory Docker repository.
conditionalExecution: |-
    Conditional Execution uses JEXL operators and expressions. [Learn More](https://commons.apache.org/proper/commons-jexl/reference/syntax.html)

     
    Examples:

     
    `<+steps.mystep.output.status> == “success”`
    `<+environment.name> != “QA”`
projectsForm_name: Enter a name for the project. [Learn more](https://ngdocs.harness.io/article/36fw2u92i4-create-an-organization)
projectsForm_color: Select a color for the project. [Learn more](https://ngdocs.harness.io/article/36fw2u92i4-create-an-organization)
projectsForm_orgIdentifier: Select an org for your project. [Learn more](https://ngdocs.harness.io/article/36fw2u92i4-create-an-organization)
passwordStrengthForm_minNumberOfCharacters: Enter a minimum length for the passwords. [Learn more](https://ngdocs.harness.io/article/gdob5gvyco-authentication-overview)
passwordExpirationForm_daysBeforePasswordExpire: After how many days the password must expire? [Learn more](https://ngdocs.harness.io/article/gdob5gvyco-authentication-overview)
passwordExpirationForm_daysBeforeUserNotified: How many days before password expiration should the user be notified?  [Learn more](https://ngdocs.harness.io/article/gdob5gvyco-authentication-overview)
lockoutPolicyForm_numberOfFailedAttemptsBeforeLockout: After how many failed logins user is locked out?  [Learn more](https://ngdocs.harness.io/article/gdob5gvyco-authentication-overview)
lockoutPolicyForm_lockOutPeriod: Enter the period for which user would be locked out.  [Learn more](https://ngdocs.harness.io/article/gdob5gvyco-authentication-overview)
samlProviderForm_displayName: Enter a name for the SAML Provider. [Learn more](https://ngdocs.harness.io/article/mlpksc7s6c-single-sign-on-saml)
samlProviderForm_groupMembershipAttr: Enter the Group Attribute Name from your SAML Provider. [Learn more](https://ngdocs.harness.io/article/mlpksc7s6c-single-sign-on-saml)
connectorDetailsStepForm_name: Enter a name for the Connector. This is the name you will use to select this Connector in stage and step settings.
awsKmsConfigForm_credType: Select a credential type for authentication. [Learn more](https://ngdocs.harness.io/article/pt52h8sb6z-add-an-aws-kms-secrets-manager)
awsKmsConfigForm_accessKey: Enter your AWS Access Key ID. [Learn more](https://ngdocs.harness.io/article/pt52h8sb6z-add-an-aws-kms-secrets-manager)
awsKmsConfigForm_secretKey: Enter the Secret Key for your AWS Access Key ID. [Learn more](https://ngdocs.harness.io/article/pt52h8sb6z-add-an-aws-kms-secrets-manager)
awsKmsConfigForm_awsArn: Enter the Amazon Resource Name (ARN).  [Learn more](https://ngdocs.harness.io/article/pt52h8sb6z-add-an-aws-kms-secrets-manager)
awsKmsConfigForm_region: Select the AWS Region for the Secrets Manager.  [Learn more](https://ngdocs.harness.io/article/pt52h8sb6z-add-an-aws-kms-secrets-manager#region)
awsKmsConfigForm_default: Make this your default secrets manager.  [Learn more](https://ngdocs.harness.io/article/pt52h8sb6z-add-an-aws-kms-secrets-manager#region)
azureKeyVaultForm_clientId: Enter the Application (client) ID of your Azure app.  [Learn more](https://ngdocs.harness.io/article/53jrd1cv4i-azure-key-vault)
azureKeyVaultForm_tenantId: Enter the Directory (tenant) ID of the Azure App Directory.  [Learn more](https://ngdocs.harness.io/article/53jrd1cv4i-azure-key-vault)
azureKeyVaultForm_subscription: Enter your Azure Subscription ID.  [Learn more](https://ngdocs.harness.io/article/53jrd1cv4i-azure-key-vault)
azureKeyVaultForm_secretKey: Enter azure authentication key.  [Learn more](https://ngdocs.harness.io/article/53jrd1cv4i-azure-key-vault)
azureKeyVaultForm_vaultName: Select the Vault you want to use. [Learn more](https://ngdocs.harness.io/article/53jrd1cv4i-azure-key-vault)
azureKeyVaultForm_default: Make this your default secrets manager. [Learn more](https://ngdocs.harness.io/article/53jrd1cv4i-azure-key-vault)
vaultConfigForm_vaultUrl: Enter the Vault URL. [Learn more](https://ngdocs.harness.io/article/s65mzbyags-add-hashicorp-vault)
vaultConfigForm_basePath: Enter the Base Secret Path. [Learn more](https://ngdocs.harness.io/article/s65mzbyags-add-hashicorp-vault)
vaultConfigForm_accessType: Select the Authentication Type.  [Learn more](https://ngdocs.harness.io/article/s65mzbyags-add-hashicorp-vault)
vaultConfigForm_authToken: Enter Periodic Token.  [Learn more](https://ngdocs.harness.io/article/s65mzbyags-add-hashicorp-vault)
vaultConfigForm_appRoleId: Enter the App Role ID.  [Learn more](https://ngdocs.harness.io/article/s65mzbyags-add-hashicorp-vault)
vaultConfigForm_secretId: Enter the Secret ID. [Learn more](https://ngdocs.harness.io/article/s65mzbyags-add-hashicorp-vault)
vaultConfigForm_engineType: Select Secret Engine Type. [Learn more](https://ngdocs.harness.io/article/s65mzbyags-add-hashicorp-vault)
vaultConfigForm_secretEngineName: Enter the name of the Secret Engine. [Learn more](https://ngdocs.harness.io/article/s65mzbyags-add-hashicorp-vault)
vaultConfigForm_secretEngineVersion: Enter the engine version. [Learn more](https://ngdocs.harness.io/article/s65mzbyags-add-hashicorp-vault)
vaultConfigForm_renewalInterv: Enter how often Harness Delegate should reload the Vault access token. [Learn more](https://ngdocs.harness.io/article/s65mzbyags-add-hashicorp-vault)
vaultConfigForm_readOnly: Select to make secrets within this vault Read-Only. [Learn more](https://ngdocs.harness.io/article/s65mzbyags-add-hashicorp-vault)
vaultConfigForm_default: Make this your default secrets manager.
stepGithubAuthForm_enableAPIAccess: Select this option if you are using this GitHub Connector for a Harness [Trigger](https://ngdocs.harness.io/article/hndnde8usz-triggering-pipelines), [Harness Git Experience](https://ngdocs.harness.io/article/utikdyxgfz-harness-git-experience-overview), or authenticating using a [GitHub App](https://ngdocs.harness.io/article/nze5evmqu1-git-hub-app-support).
deployService_name: "Enter a name for this Service. You can propagate this Service in subsequent stages by selecting its name in that stage's Service settings. "
specifyYourEnvironment: |-
    Select or create a new Environment. You can select this Environment in subsequent stages.

    Environments represent your deployment targets logically (QA, Prod, etc). You can add the same Environment to as many stages are you need. Infrastructure Definitions represent your target infrastructure physically. They are the actual clusters, hosts, etc.

    By separating Environments and Infrastructure Definitions, you can use the same Environment in multiple stages while changing the target infrastructure settings with each stage.
k8InfraConnector: |-
    Select or create the Connector that connects Harness to your target cluster. [Learn More](https://ngdocs.harness.io/article/0ud2ut4vt2)

    Here's a [video](https://youtu.be/wUC23lmqfnY) that walks through setting up a Kubernetes Cluster Connector.
k8InfraNamespace: |-
    Enter the target namespace in target cluster. 

    The namespace must already exist during deployment. Harness will not create a new namespace if you enter one here. If you leave this setting empty, the `default` namespace is used. [Learn More](https://ngdocs.harness.io/article/0ud2ut4vt2)
k8InfraReleaseName: |-
    During deployment Harness creates a ConfigMap listing the resources of the release and uses the **Release name** for tracking them. 

    The **Release name** is a combination of `release-` and a unique string created using the Harness expression `<+INFRA_KEY>`. 

    For example, in a Kubernetes deployment you can see `harness.io/release-name=release-2f9eadcc06e2c2225265ab3cbb1160bc5eacfd4f`.

    The release name must be unique across the cluster. `release-<+INFRA_KEY>` ensures a unique name.

    `release-` is used as a prefix because Kubernetes service and pod names must follow RFC-1035 and must consist of lowercase alphanumeric characters or '-', start with an alphabetic character, and end with an alphanumeric character.
manifestDetails_identifier: Enter a name that identifies this manifest. [Learn More](https://ngdocs.harness.io/article/ssbq0xh0hx)
manifestDetails_gitFetchType: Select a branch or commit ID for the manifest.
manifestDetails_commitId: Enter the commit ID in the repo where the manifest is located.
manifestDetails_branch: Enter the branch in the repo where the manifest is located, such as `main`.
imagePath_imagePath: |+
    Enter the name of the artifact you want to deploy, such as `library/nginx`. [Learn More](https://ngdocs.harness.io/article/4ifq51cp0i)

    Official images in public repos often need the label `library`, e.g. `library/tomcat`.

    Wildcards are not supported.

imagePath_tag: Enter the Docker [image tag](https://docs.docker.com/engine/reference/commandline/tag/).
setContainerResources: |
    Resources limits allow setting maximum values for the resources the container is allowed to use at runtime.
    Use “Limit Memory” to limit the memory that the container can use. Limits for memory are measured in bytes. You can express memory as a plain integer or as a fixed-point number using one of these suffixes: G, M. You can also use the power-of-two equivalents: Gi, Mi.
    Use “Limit CPU” to limit the number of cores that the container can use. Limits for CPU resources are measured in cpu units. Fractional requests are allowed. The expression 0.1 is equivalent to the expression 100m, which can be read as "one hundred millicpu"
timeout: |
    You can use:
    w for weeks
    d for days
    h for hours
    m for minutes
    s for seconds
    ms for milliseconds
image: The name and tag of a Docker image to use in this stage. For example, a database container or a container to run integration tests on. Include the image name and tag. Harness will default to the latest tag if unspecified. You can use any Docker image from any public or private Docker registry.
privileged: Enable this option to run the container with escalated privileges. This is the equivalent of running a container with the Docker --privileged flag.
tags: Specify one or more tags for the Docker image
optimize: Enables redo snapshot mode
dockerfile: If not provided assumed to be in the root folder of the codebase
context: Context represents a directory containing a Dockerfile which kaniko will use to build your image. For example, a COPY command in your Dockerfile should refer to a file in the build context.
labels: Use Labels to add metadata to the Docker image
buildArgs: Build-time variables
target: Build the specified stage as defined inside the Dockerfile
region: AWS Region
imageName: The name of the image that will be pushed to the target container registry.
gcsBucket: GCS Bucket
sourcePath: Use regex to upload multiple files
gcsS3Target: The path to store the cache in, relatively to the bucket. If not provided the cache will be save to [bucket]/
connector: Container Registry to use to download the image use to run commands on
restoreCacheKey: The key that can be used to restore this cache. You can use the checksum macro to create a key that is based on a file’s checksum. For example, myApp-{ { checksum filePath1 } }
archiveFormat: Select archive format. Default is Tar
failIfKeyNotFound: Fail step if the key doesn’t exist. Default is False.
s3Bucket: S3 Bucket
endpoint: Endpoint for S3 compatible providers (not needed for AWS).
pathStyle: Select whether to use Virtual Hosted Style (http://bucket.host/key) or Path Style (http://host/bucket/key). For MinIO use Path Style (true). Default value is false.
reportPaths: Enter paths to file(s) that store results in the JUnit XML format. Regex is supported.
environmentVariables: Environment variables injected into the container to be used in the commands.
outputVariables: Output Variables can be used to expose Environment Variables to be used by other steps/stages of the pipeline
saveCacheKey: The key the cache will be identified by. You can use the checksum macro to create a key that is based on a file’s checksum. For example, myApp-{ { checksum filePath1 } }
saveCacheSourcePaths: A list of files/folders to cache
saveCacheOverride: Select whether you want to override the cache if the key already exists. default is true
namespace: Namespace must exist
cloneCodebase: Unless disabled, Harness automatically clones your codebase repository before executing the steps of this stage
dependencyConnector: Container registry to pull the service dependency image from
dependencyEnvironmentVariables: Environment variables injected into the container
dependencyEntryPoint: Overrides the image ENTRYPOINT. Commands should be in exec form. Each command and parameter should be added separately. [Learn More](https://ngdocs.harness.io/article/vo4sjbd09g-configure-service-dependency-step-settings)
dependencyArgs: Overrides the image COMMAND
dockerHubConnector: Docker Connector to use for uploading the image
dockerHubRepository: Docker repository. For example, "plugins/s3"
dockerHubRemoteCache: The remote cache repository needs to be created in the same account and organization as the build image. The repository must already exist for caching to work
ecrConnector: AWS connector to use for uploading the image to ECR
ecrAccount: AWS Account ID
ecrRemoteCache: The remote cache repository needs to be created in the same account and region as the build image. The repository must already exist for caching to work
gcrConnector: GCP connector to use for uploading the image to GCR
gcrHost: GCR Host
gcrProjectID: GCR Project ID
gcrRemoteCache: The remote cache repository needs to be created in the same host and project as the build image. The repository will be automatically created if it doesn’t exist.
gcsConnector: GCP connector to use for uploading the artifact(s) to GCS
jFrogArtifactoryTarget: Repository name relative to the server URL in the connector. If pom.xml is not present then target should be full path to artifacts folder (groupID/artifactID/version)
pluginImage: The name of the Plugin Docker image. The image name should include the tag and will default to the latest tag if unspecified. You can use any docker image from any docker registry, including docker images from private registries
pluginSettings: Plugin specific settings. Please refer to the plugin's documentation page
restoreCacheGcpConnector: GCP connector to use for restoring the cache from GCS
restoreCacheAwsConnector: AWS connector to use for restoring the cache from S3
runCommand: POSIX shell script executed inside the container. The script is invoked as if it were the container’s entrypoint.
runTestsArgs: The arguments to be passed to the buildTool. For maven, it will be a goal
runTestsBuildTool: Build automation tool
runTestsLanguage: The programming language of the source code to build
runTestsPackages: List of source code package prefixes separated by comma. E.g. com.company., io.company., migrations.
runTestsTestAnnotations: "List of test annotations used in unit testing. They should be separated by comma. Any method annotated with this will be treated as test method. The defaults are: org.junit.Test, org.junit.jupiter.api.Test, org.testng.annotations.Test"
runTestsPreCommand: Commands used for setting up the environment before running the tests
runTestsPostCommand: Commands used for cleaning up the environment after running the tests
s3Connector: AWS connector to use for uploading the artifact(s) to S3
gcpConnector: GCP connector to use for saving the cache to GCS
saveCacheS3Connector: AWS connector to use for saving the cache to S3
stageSpecificationsSharedPaths: By default, all of a stage’s steps use the same workspace to share data. If you need to share additional paths between steps, add Shared Paths.
connectorDetailsStepFormGithub_name: Enter a name for this Connector. You will use this name to select the Connector.
gitDetailsStepForm_url: |-
    Enter the URL for your repo or account:

    - **Repos:** copy the URL provided by the Git provider. For example, see GitHub's [**Code** setting](https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/cloning-a-repository-from-github/cloning-a-repository).
    - **Accounts:** The URL of your Git provider account, such as `https://github.com/mycompany`. In **Test Repository**, enter a repo to test the connection. 

    [Learn More](https://ngdocs.harness.io/category/xyexvcc206)
gitDetailsStepForm_validationRepo: |-
    Enter a repo name to test the credentials. The Connector will connect to the repo to test account credentials. The repo is not linked to the Connector.

    The Connector will still be created at the Account level.
connectorDetailsStepFormAws_name: Enter a name for this AWS Connector. You will use the name to select this Connector in Pipeline steps and settings. [Learn More](https://ngdocs.harness.io/article/m5vkql35ca)
stepAwsAuthForm_crossAccountAccess: |-
    Select this option if you want to use one AWS account for the connection, but you want to deploy or build in a different AWS account. 

    In this scenario, the AWS account used for AWS access in **Credentials** will assume the IAM role you specify in **Cross-account role ARN** setting.

    This option uses the [AWS Security Token Service (STS)](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp.html) feature.

    [Learn More](https://ngdocs.harness.io/article/m5vkql35ca)
stepAwsAuthForm_crossAccountRoleArn: |-
    The Amazon Resource Name (ARN) of the role that you want to assume. This is an IAM role in the target AWS account.

    The assumed role must have all the IAM policies required to perform your Harness operations, such as Amazon S3, ECS (Existing Cluster), and AWS EC2 policies. For more information, see [Assuming an IAM Role in the AWS CLI](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-role.html) from AWS.
stepAwsAuthForm_externalId: |-
    If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.

    For more information, see [How to Use an External ID When Granting Access to Your AWS Resources to a Third Party](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html) from AWS.
connectorDetailsStepFormGcp_name: Enter a name for this Connector. You will use this name to select the Connector.
connectorDetailsStepFormK8sCluster_name: Enter a name for this Connector. You will use this name to select the Connector in Pipeline steps and settings. [Learn More](https://ngdocs.harness.io/article/sjjik49xww)
k8ClusterForm_masterUrl: |-
    The Kubernetes master node URL. The easiest method to obtain the master URL is using kubectl:

    ```
    kubectl cluster-info
    ```

    [Learn More](https://ngdocs.harness.io/article/sjjik49xww)
connectorDetailsStepFormArtifactory_name: Enter a name for this Connector. You will use this name to select the Connector in Pipeline steps and settings. [Learn More](https://ngdocs.harness.io/article/euueiiai4m)
stepArtifactoryAuthForm_artifactoryServerUrl: |-
    Enter in your base URL followed by your module name.

    For most artifacts, use `https://mycompany.jfrog.io/module_name`.

    In some cases, you can use `https://server_name/artifactory/module_name`.

    The URL really depends on how you have set up Artifactory, and whether it is local, virtual, remote, or behind a proxy.

    To ensure you use the correct URL, copy it from your Artifactory settings.

    [Learn More](https://ngdocs.harness.io/article/euueiiai4m)
connectorDetailsStepFormDockerRegistry_name: Enter a name for this Connector. You will use this name to select the Connector in Pipeline steps and settings. [Learn More](https://ngdocs.harness.io/article/u9bsd77g5a)
dockerAuthForm_dockerRegistryUrl: |-
    Enter the URL of the Docker Registry. The Docker Registry URL for Docker Hub is `https://registry.hub.docker.com/v2/` or `https://index.docker.io/v2/`.

    [Learn More](https://ngdocs.harness.io/article/u9bsd77g5a)
helmRepoAuthForm_helmRepoUrl: The URL of the chart repo. [Learn More](https://ngdocs.harness.io/article/a0jotsvsi7)
connectorDetailsStepFormHttpHelmRepo_name: |+
    Enter a name for this Connector. You will use this name to select the Connector in Pipeline steps and settings. [Learn More](https://ngdocs.harness.io/article/a0jotsvsi7)

    For Helm charts stored in repos such as Amazon S3 or GCS (Google Cloud Storage), you will need to create a cloud platform Connector for that repo. For more information, see [Cloud Platform Connectors](https://ngdocs.harness.io/category/1ehb4tcksy).

connectorDetailsStepFormNexus_name: Enter a name for this Connector. You will use this name to select the Connector in Pipeline steps and settings. [Learn More](https://ngdocs.harness.io/article/faor0dc98d)
nexusAuth_nexusServerUrl: |-
    The URL that you use to connect to your Nexus server. For example, `https://nexus2.dev.mycompany.io`. [Learn More](https://ngdocs.harness.io/article/faor0dc98d)

    Ensure the user account credentials you enter have the following permissions in the Nexus Server.

    - Repo: All repositories (Read)
    - Nexus UI: Repository Browser

    If this Connector is used as a Docker Repo, the user account needs:

    - List images and tags
    - Pull images
nexusAuth_nexusVersion: |-
    Harness lists the supported Nexus versions, 2.x and 3.x:

    - For Nexus 2.x, Harness supports repository formats Maven, npm, and NuGet. See Sonatype's website at [Supported Formats](https://help.sonatype.com/repomanager3/supported-formats).

    - For Nexus 3.x, Harness supports repository formats Docker 3.0 and greater, Maven, npm, NuGet.
connectorDetailsStepFormCodecommit_name: Enter a name for this Connector. You will use this name to select the Connector in Pipeline steps and settings. [Learn More](https://ngdocs.harness.io/article/jed9he2i45)
awsCCDetailsForm_urlType: |-
    You can select **Region** or **Repository**.

    You can add a connection to your entire region or just a repo in the account. Selecting a region enables you to use one Connector for all of your subordinate repositories.

    You must enter a repo URL even if you select region. Harness will use the repo URL Later to test this connection.

    [Learn More](https://ngdocs.harness.io/article/jed9he2i45)
awsCCDetailsForm_url: Enter the path of the AWS CodeCommit repository to use.
connectorDetailsStepFormBitbucket_name: Enter a name for this Connector. You will use this name to select the Connector in Pipeline steps and settings. [Learn More](https://ngdocs.harness.io/article/iz5tucdwyu)
connectorDetailsStepFormJira_name: Enter a name for this Connector. You will use this name to select the Connector in Pipeline steps and settings. [Learn More](https://ngdocs.harness.io/article/ud8rysntnz)
k8InfraAllowSimultaneousDeployments: By default, Harness queues deployments to the same infrastructure to avoid conflicts. If you want to allow simultaneous deployments to this infrastructure, enable this option.
infraProvisionerBase_provisionerEnabled: Select this option to use an infrastructure provisioner to dynamically provision the target infrastructure for the deployment. [Learn More](https://ngdocs.harness.io/article/boug6e884h)
terraformPlanEditView-tfPlan-INFRASTRUCTURE_name: |-
    Enter a name for this step. 

    The Terraform Plan step can provision any resource, including the target infrastructure for a deployment. [Learn More](https://ngdocs.harness.io/article/uznls2lvod)
terraformPlanEditView-tfPlan-INFRASTRUCTURE_spec.configuration.command: Identify if the plan created by this step will be used with a Terraform Apply or Terraform Destroy step. [Learn More](https://ngdocs.harness.io/article/uznls2lvod)
terraformPlanEditView-tfPlan-INFRASTRUCTURE_spec.provisionerIdentifier: |-
    Enter a unique value in **Provisioner Identifier**.

    The Provisioner Identifier identifies the provisioning done in this step. You use the Provisioner Identifier in additional steps to refer to the provisioning done in this step. [Learn More](https://ngdocs.harness.io/article/uznls2lvod)

    The most common use of Provisioner Identifier is between the Terraform Plan and Terraform Apply steps. To have the Terraform Apply step apply the provisioning from this Terraform Plan step, you use the same Provisioner Identifier in both steps.
terraformEdit-TerraformApply-INFRASTRUCTURE_name: |-
    Enter a name for this step. 

    When provisioning target infrastructure, the Terraform Apply step simply inherits its configuration from the Terraform Plan step you already configured. [Learn More](https://ngdocs.harness.io/article/uznls2lvod)
terraformEdit-TerraformApply-INFRASTRUCTURE_spec.configuration.type: |-
    When provisioning target infrastructure, select **Inherit From Plan**. If you select **Inline**, then you aren't using the previous Terraform Plan step. You are entering separate Terraform files and settings.
    [Learn More](https://ngdocs.harness.io/article/uznls2lvod)
terraformEdit-TerraformApply-INFRASTRUCTURE_spec.provisionerIdentifier: When provisioning target infrastructure, enter the same Provisioner Identifier you entered in the Terraform Plan step. [Learn More](https://ngdocs.harness.io/article/uznls2lvod)
terraformEdit-TerraformDestroy-INFRASTRUCTURE_name: |-
    Enter a name for this step. 
    When provisioning target infrastructure, the Terraform Delete step deletes the infrastructure provisioned by the Terraform Apply step. [Learn More](https://ngdocs.harness.io/article/uznls2lvod)
terraformEdit-TerraformDestroy-INFRASTRUCTURE_spec.configuration.type: |-
    When provisioning target infrastructure, select **Inherit from Apply**.

    The Terraform Delete step will delete the infrastructure provisioned by the Terraform Apply step. [Learn More](https://ngdocs.harness.io/article/uznls2lvod)
terraformEdit-TerraformDestroy-INFRASTRUCTURE_spec.provisionerIdentifier: |-
    The Provisioner Identifier uniquely identifies the provisioning done by specific Terraform steps.

    When provisioning target infrastructure, enter the same Provisioner Identifier used but the Terraform Apply step.

    The Terraform Delete step will delete the infrastructure provisioned by the Terraform Apply step. [Learn More](https://ngdocs.harness.io/article/uznls2lvod)
jiraCreate_name: |-
    Enter a name for this step.

    You can use this step to create a Jira issue as part of the execution of a Pipeline. [Learn More](https://ngdocs.harness.io/article/yu40zr6cvm)

    Jira issues are often used as part of a Jira Approval stage. [Learn More](https://ngdocs.harness.io/article/2lhfk506r8)

    [Video walkthrough](https://youtu.be/xVeICozz4lU)
jiraCreate_spec.projectKey: Select the Jira project where you want to create a ticket. [Learn More](https://ngdocs.harness.io/article/yu40zr6cvm)
jiraCreate_spec.issueType: Select a Jira issue type from the list of types in the Jira project you selected. [Learn More](https://ngdocs.harness.io/article/yu40zr6cvm)
jiraCreate_spec.summary: Add a summary for the new Jira ticket.
harnessApproval_name: Enter a name for this step. The Manual Approval step let's you specify Harness User Group(s) to approve or reject a Pipeline at any point in its execution. [Learn More](https://ngdocs.harness.io/article/fkvso46bok)
harnessApproval_spec.includePipelineExecutionHistory: Enable this option to provide approvers with the execution history for this Pipeline. This can help approvers make their decision. [Learn More](https://ngdocs.harness.io/article/fkvso46bok)
harnessApproval_spec.approvers.userGroups: Select the Harness User Groups that will approve the step. [Learn More](https://ngdocs.harness.io/article/fkvso46bok)
harnessApproval_spec.approvers.minimumCount: Enter how many of the Users in the User Groups must approve the step. [Learn More](https://ngdocs.harness.io/article/fkvso46bok)
harnessApproval_spec.approvers.disallowPipelineExecutor: Enable this option if you don't want to allow the User that initiated the Pipeline execution to approve this step. [Learn More](https://ngdocs.harness.io/article/fkvso46bok)
terraformRollback_name: |+
    Enter a name for this step. 
    Use the Terraform Rollback step to roll back your infrastructure and resources and return your environment to its pre-deployment state. [Learn More](https://ngdocs.harness.io/article/jgi6d73noy)

terraformRollback_spec.provisionerIdentifier: |-
    Enter the same Provisioner Identifier you used in the Terraform Plan and/or Apply steps that provisioned the infrastructure you want to roll back. Harness will roll back the exact infrastructure provisioned in those steps.
    [Learn More](https://ngdocs.harness.io/article/jgi6d73noy)
shellScriptForm_name: |-
    Enter a name for this step. The Shell Script step can execute scripts in the shell session of the stage in the following ways:

    - Execute scripts on the host running a Harness Delegate. You can use **Delegate Selector** in **Advanced** to identify which Harness Delegate to use.
    - Execute scripts on a remote target host.

    See **Execution Target** in **Optional Configuration** to select where the script is run. [Learn More](https://ngdocs.harness.io/article/k5lu0u6i1i)
shellScriptForm_spec.shell: |-
    Enter a bash script. For example, here is a script that exports the variable names `BUILD_NO` and `LANG`:

    ```
    export BUILD_NO="345"
    export LANG="en-us" 
    ```

    You must use quotes around the value because environment variables are Strings.

    You can use Harness [variable expressions](https://ngdocs.harness.io/article/lml71vhsim-harness-variables) in your script and its comments. Harness will attempt to evaluate and render the variable expressions at runtime. Do not use variable expressions that Harness cannot evaluate at this step in the Execution.
    [Learn More](https://ngdocs.harness.io/article/k5lu0u6i1i)
k8BgSwap_name: Enter a name for this step. In this step, Harness swaps the primary service (prod traffic) to the pod set running the new app and the stage service (stage traffic) to the set running the old app. [Learn More](https://ngdocs.harness.io/article/mog5tnk5pi)
k8BG_name: |-
    Enter a name for this step. 

    This step deploys your new app version to the stage pod set. 

    The first time this step is run it creates any needed Kubernetes services and pod sets for the app.

    The **Swap** step follows this step. It swaps the primary service to the new app version's pod set, and the stage service to old app version's stage pod set.

    [Learn More](https://ngdocs.harness.io/article/mog5tnk5pi)
k8Apply_name: |-
    Enter a name for this step. The K8s Apply step allows you to deploy any resource you have set up in the **Manifests** section in **Service**.

    By default, the Harness Kubernetes Rolling, Canary, and Blue Green steps will deploy all of the resources you have set up in the **Manifests** section.

    In some cases, you might have resources in **Manifests** that you do not want to deploy as part of the main deployment, but want to apply as another step in the stage.

    In these cases, you use the K8s Apply step to deploy those resources. [Learn More](https://ngdocs.harness.io/article/00el61pzok)
k8DeleteData_name: Enter a name for this step. The K8s Delete step can remove any deployed Kubernetes resources. [Learn More](https://ngdocs.harness.io/article/eaj0xuegln)
k8DeleteData_spec.deleteResources.type: |-
    Select the resource(s) you want removed:

    - **Resource Name:** Use a resource name in the format `[namespace]/Kind/Name`, with `namespace` being optional. For example, `Deployment/harness-example-deployment-canary`.
    - **Manifest Path:** Enter the path to the manifest for the resource you want to delete. The path is relative to the folder path entered in **File/Folder Path** in the **Manifest Details** settings.
    - **Release Name:** Deletes all of the resources for a release. If you select the **Delete namespace** option, Harness will delete the namespace(s) defined in the release.

    [Learn More](https://ngdocs.harness.io/article/eaj0xuegln)
k*CanaryDelete_name: Enter a name for this step. The **Canary Delete** step is used to clean up the workload deployed by the [Canary](https://ngdocs.harness.io/article/17wrdeuv0x-) step. [Learn More](https://ngdocs.harness.io/article/922mtcvank)
k8RolloutDeploy_name: |-
    Enter a name for this step. The **K8s Rollout Deploy** step performs a Kubernetes [rolling update strategy](https://ngdocs.harness.io/article/0zsf97lo3c-deployment-concepts). 

    All nodes within a single environment are incrementally added one-by-one with a new service/artifact version. The rolling update uses the number of pods you specified in **Manifests** (number of replicas). [Learn More](https://ngdocs.harness.io/article/2bwlugh9gi)
k8CanaryDeploy_name: Enter a name for this step. The **K8s Canary Deploy** step sets how many pods are created for a Canary deployment of the files in your Service Definition **Manifests** section. [Learn More](https://ngdocs.harness.io/article/i5p4feil89)
k8Scale_name: Enter a name for this step. The **K8s Scale** step you can scale the number of running pods up or down by count or percentage. [Learn More](https://ngdocs.harness.io/article/jxe5z9domw-scale-kubernetes-replicas)
k8Scale_spec.workload: |-
    Enter the name of the resource to scale in the format `[namespace/]Kind/Name`, with `namespace` optional. For example: 

    ```
    default/Deployment/harness-example
    ```

    You can scale a Deployment, DaemonSet, or StatefulSet.

    You can only enter one resource in **Workload**. To scale another resource, add another **K8s Scale** step. 

    [Learn More](https://ngdocs.harness.io/article/jxe5z9domw-scale-kubernetes-replicas)
k8RollingRB_name: |
    Enter a name for this step. The **K8s Rollout Rollback** step will roll back the workloads deployed by the Rolling Deployment step. [Learn More](https://ngdocs.harness.io/article/xsla71qg8t)

    **Rollback rolls back workloads only.** If there are other objects or operations executed in your stage, Harness does not roll those back.
terraformEdit-TerraformDestroy-EXECUTION_name: |-
    Enter a name for this step. The **Terraform Destroy** step removes any provisioned infrastructure, just like running the `terraform destroy` command. [Learn More](https://ngdocs.harness.io/article/j75xc704c8)

    The **Terraform Destroy** step is independent of any other Terraform provisioning steps. It's not restricted to removing the infrastructure deployed in its stage. It can remove any infrastructure you've provisioned *using Harness*.

    The **Terraform Destroy** step can also be used as part of target infrastructure provisioning. [Learn More](https://ngdocs.harness.io/article/uznls2lvod-provision-infra-dynamically-with-terraform)
terraformEdit-TerraformDestroy-EXECUTION_spec.configuration.type: |-
    There are three options:

    - **Inline:** Removes the provisioned resources you identify using **Provisioner Identifier** and other settings. 

    - **Inherit from Plan:** Removes the resources defined in the Harness **Terraform Plan** step that you identify using **Provisioner Identifier**. Similar to `terraform plan -destroy`.

    - **Inherit from Apply:** Removes the resources defined in the Harness **Terraform Apply** step that you identify using **Provisioner Identifier**. Similar to `terraform destroy`.

    [Learn More](https://ngdocs.harness.io/article/j75xc704c8)
terraformEdit-TerraformDestroy-EXECUTION_spec.provisionerIdentifier: Enter the same **Provisioner Identifier** you used in the **Terraform Plan** or **Terraform Apply** step that planned/provisioned the resources you want to destroy. [Learn More](https://ngdocs.harness.io/article/j75xc704c8)
terraformEdit-TerraformApply-EXECUTION_name: |-
    Enter a name for this step.

    You can apply a Terraform plan or script using the **Terraform Apply** step. [Learn More](https://ngdocs.harness.io/article/hdclyshiho)

    Typically the **Terraform Apply** step is used with the **Terraform Plan** step to apply a plan. 

    For steps on using the Terraform Plan step, see [Plan Terraform Provisioning with the Terraform Plan Step](https://ngdocs.harness.io/article/52n3j0ci72).
terraformEdit-TerraformApply-EXECUTION_spec.configuration.type: |-
    Select **Inline** or **Inherit from Plan**.

    - If you select **Inherit from Plan**, you'll enter the unique Id used by a **Terraform Plan** step in **Provisioner Identifier**.

    - If you select **Inline**, you'll configure this **Terraform Apply** step to use a Terraform script without any **Terraform Plan** step.

    [Learn More](https://ngdocs.harness.io/article/hdclyshiho)
terraformEdit-TerraformApply-EXECUTION_spec.provisionerIdentifier: |-
    The **Provisioner Identifier** identifies the provisioning applied in this step. 

    - If you selected **Inherit from Plan** in **Configuration Type**, enter the Id used by the **Terraform Plan** step for the plan you want to apply.

    - If you selected **Inline** in **Configuration Type**, create a new Id.

    [Learn More](https://ngdocs.harness.io/article/hdclyshiho)
terraformPlanEditView-tfPlan-EXECUTION_name: |-
    Enter a name for this step. The **Terraform Plan** step runs a Terraform script as a Terraform plan.

    You can then add a **Terraform Apply** step later in your stage to apply the plan. [Learn More](https://ngdocs.harness.io/article/52n3j0ci72)
terraformPlanEditView-tfPlan-EXECUTION_spec.configuration.command: |-
    Select how you want this plan used later in the stage:

    - **Apply:** The plan will be applied by a **Terraform Apply** step later in your stage.
    - **Destroy:** The plan will be applied by a **Terraform Destroy** step later in your stage.

    [Learn More](https://ngdocs.harness.io/article/52n3j0ci72)
terraformPlanEditView-tfPlan-EXECUTION_spec.provisionerIdentifier: |-
    Enter a unique string to identify the provisioning configured in this step. 

    You will use this **Provisioner Identifier** in additional steps to refer to the provisioning set up in this step.

    The most common use of **Provisioner Identifier** is between the **Terraform Plan** and **Terraform Apply** steps. [Learn More](https://ngdocs.harness.io/article/52n3j0ci72)
barrierStep_name: |-
    Enter a name for this step. 

    Barriers allow you to synchronize different stages in your Pipeline, and control the flow of your deployment systematically.

    Before you add a **Barrier** step to a stage, barriers must be are added in the Pipeline's **Flow Control** settings. [Learn More](https://ngdocs.harness.io/article/dmlf8w2aeh)
barrierStep_spec.barrierRef: |-
    Select a Barrier name for the new barrier. [Learn More](https://ngdocs.harness.io/article/dmlf8w2aeh)

    Barriers are added in the Pipeline's **Flow Control** settings. If you do not see any names in **Barrier Reference**, then no barriers have been added to **Flow Control**.

    You can have multiple barriers in a stage. Every barrier in the same stage must use a unique Barrier Reference.
